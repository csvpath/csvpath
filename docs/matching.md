<a name="matching"></a>

# Matching

The match part is the third and last part of a csvpath, behind the root and scanning part. Like the scanning part, it is bracketed.

Matches have space separated components that are ANDed or ORed together. The components' order is meaningful. Generally, components are tested left to right, top to bottom.

A match component is one of these types:

- [Term](#term)
- [Function](#function)
- [Variable](#variable)
- [Header](#header)
- [Equality](#equality)
- [Reference](#reference)

These components can be combined in endless ways. The organization of a csvpath's match part is `[x x x x]` where each `x` is a match component, with all of the match components ANDed or ORed together. There can be any number of match components in a csvpath statement.

Since equalities are match components, `[ "x" == "y" "z" == "z" ]` is a legal csvpath match part containing two top-level match components. Each of those two components is an Equality. Each Equality holds two Term component literals, `"x"` and `"y"`, and `"z"` and `"z"`.

In this case, if the evaluation ANDs match components, the default, this statement will never match because `"x"` never equals `"y"`. If evaluation is switched to OR, the statement will always match because `"z"` always equals `"z"`. The switch from AND to OR can be done programmatically or, more typically, using a mode declaration in a csvpath comment. Modes are covered in the page on comments.

Some of these component types can be modified with qualifiers. A qualifier changes the behavior of a match component. It is set by adding a dot + a name to the match component name.

For example, `count.cars(#color=="blue")` is a variation on `count(#color=="blue")`. The difference is that `count()`'s variable is named `cars`, rather than a random string. Likewise `count.cars.onmatch(#color=="blue")` increments the count of the `cars` variable only if the rest of the line matches.

[Read more about qualifiers here](https://github.com/csvpath/csvpath/blob/main/docs/qualifiers.md).

There is no limit to the functionality you can include in a single csvpath using match components. However, functions have different performance characteristics. You should test both the performance and functionality of your paths, just as you would when working with SQL.


<a name="Components"></a>

# Match Component Types

<a name="term"></a>

## Term

A string, number, or regular expression value.

<table>
    <thead>
        <tr>
            <th>
                Returns
            </th>
            <th>
                Matches
            </th>
            <th>
                Examples
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                A value
            </td>
            <td>
                Always matches
            </td>
            <td>
                <ul>
                    <li/> <code>"a value"</code>
                    <li/> <code>3</code>
                </ul>
            </td>
        </tr>
    </tbody>
</table>


<a href='https://github.com/dk107dk/csvpath/blob/main/docs/terms.md'>Read about terms here</a>.


<a name="function"></a>

## Function

A composable unit of functionality called once for every row scanned. CsvPath Validation Language has over 150 functions. As a language, it is very much functions-oriented.

|Returns    | Matches    | Examples      |
|-----------|------------|---------------|
|Calculated | Calculated | `count()`     |

<a href='https://github.com/dk107dk/csvpath/blob/main/docs/functions.md'>Read about functions here</a>.


<a name="variable"></a>

## Variable

A stored value that is set or retrieved once per row scanned.

|Returns | Matches | Examples      |
|--------|---------|---------------|
|A value | True when set. (Unless the `onchange` qualifier is used). Alone it is an existence test. | `@firstname` |

<a href='https://github.com/dk107dk/csvpath/blob/main/docs/variables.md'>Read about variables here</a>.


<a name="header"></a>

## Header

A named header or a header identified by 0-based index.
_(CsvPath avoids the word "column" for reasons we'll go into later in the docs)._

|Returns | Matches | Examples      |
|--------|---------|---------------|
|A value | Calculated. Used alone it is an existence test. | `#area_code` |

<a href='https://github.com/dk107dk/csvpath/blob/main/docs/headers.md'>Read about headers here</a>.


<a name="equality"></a>

## Equality

Two of the other types joined with an "=" or "==" or the when-do operator `->`.

|Returns | Matches | Examples      |
|--------|---------|---------------|
|Calculated | Equivalence test match is calculated | `#area_code == 617` |
|No value | When-do matches when left side matches | `#area_code -> print("area code is $.headers.area_code")` |
|No value | Assignment always matches | `@code = #area_code` |


<a name="reference"></a>

## Reference

References are a way of pointing to data generated by other csvpaths. Referenced data is held by a CvsPaths instance. It is stored in its named-results. The name is the one that identified the paths that generated it.

References can point to:
- Variables
- Headers

The form of a reference is:

```bash
    $named_path.variables.firstname
```

This reference looks in the results named for its CSV file. The qualifier `variables` indicates the value is a variable named `firstname`.

|Returns    | Matches                                   | Examples               |
|-----------|-------------------------------------------|------------------------|
|Calculated | True at assignment, otherwise calculated. | `@q = $orders.variables.quarter` |


Read <a href='https://github.com/dk107dk/csvpath/blob/main/docs/references.md'>more about references here</a>.

